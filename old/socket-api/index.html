<!doctype html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Socket编程 —— Socket API | Socket编程 —— Socket API</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" media="screen">
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link href="/feed.atom" rel="alternate" title=" Socket编程 —— Socket API" type="application/atom+xml">
    
    <link rel="stylesheet" href="/static/pygments.css"  type="text/css">
    
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?7972bc564f84e320d4f261fe1ada61da";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

</head>

<body>
<div class="box">



<div class="container">
        <h1 class="title">Socket编程 —— Socket API</h1>

    <p>套接字接口(或者简称套接字)就是应用程序和网络协议的接口，主要用于实现进程间通信，在计算机网络通信方面被广泛使用。本文主要学习和记录<code>Python</code> <code>Socket</code>编程中的常见<code>API</code>接口。<code>Python</code>的<code>socket</code>库只是底层<code>C</code>库的简单封装，接口参数和<code>C</code>库大同小异。</p>
<h3>socket</h3>
<p><code>socket</code>是<code>Python</code>的套接字类，通过<code>__init__</code>方法生成套接字对象，其签名如下:</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_sock</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>其中，参数<code>family</code>表示协议族，<code>AF_INET</code>指定使用<code>IPv4</code>协议，<code>AF_INET6</code>指定使用<code>IPv6</code>协议；参数<code>type</code>表示套接字类型，<code>SOCK_STREAM</code>指定使用面向流的<code>TCP</code>协议，<code>SOCK_DGRAM</code>指定使用面向数据报的<code>UDP</code>协议；<code>proto</code>表示协议号，一般为<code>0</code>；<code>_sock</code>为真正的<code>socket</code>对象，代表一个网络连接的端点，这个参数一般用在共享套接字上：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;dup() -&gt; socket object</span>
<span class="sd">    Return a new socket object connected to the same system resource.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">_socketobject</span><span class="p">(</span><span class="n">_sock</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="p">)</span>
</pre></div>


<h3>close</h3>
<p><code>close</code>用于关闭一个套接字，签名：</p>
<div class="codehilite"><pre><span></span> <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>这里需要注意的是，当多进程共享一个套接字，调用<code>close</code>则将套接字引用计数减1，减至0才关闭。而多线程共享一个套接字，引用计数是不会增加的。</p>
<h3>bind</h3>
<p><code>bind</code>方法用于绑定套接字的本地端点地址。其签名如下：</p>
<div class="codehilite"><pre><span></span> <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>对于IP套接字，参数<code>address</code>是一个元组 <code>(host, port)</code>，<code>host</code>表示本地地址，<code>port</code>表示端口号。客户端一般不必调用<code>bind</code>方法，服务端需要。在不调用<code>bind</code>的情况下，内核会确定IP地址，并分配临时端口，这种情况很适合客户端，因此客户端在调用<code>connect</code>之前不调用<code>bind</code>方法。而服务端需要一个确定的IP和端口，因此需要调用<code>bind</code>指定地址和端口。一般情况下，服务器都有多个IP地址，除了环路地址<code>127.0.0.1</code>外，还有局域网和公网地址，如果<code>bind</code>绑定的是环路地址<code>127.0.0.1</code>，则只有本机通过环路地址才能访问，如果需要通过任一IP地址都能访问到，可以绑定通配地址<code>0.0.0.0</code>。</p>
<h3>listen</h3>
<p>当创建一个套接字时，默认为主动套接字，也就是说，是一个将调用<code>connect</code>发起连接的客户套接字。<code>listen方</code>法则将此套接字置于监听状态，指示内核应接受指向该套接字的状态请求。所以此方法仅在服务端调用，且只能用于面向连接的流套接字。其签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">listen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backlog</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>参数<code>backlog</code>表示连接请求对列的大小。当队列满时，新的连接请求将被拒绝。</p>
<h3>connet</h3>
<p><code>connet</code>使客户端套接字与特定服务端的特定端口的套接字进行连接。其签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>参数<code>address</code>同<code>bind</code>中的参数<code>address</code>。</p>
<p>该方法仅用于客户端：</p>
<ul>
<li>可用于<code>TCP</code>客户端：建立连接</li>
<li>也可以用于<code>UDP</code>：指定服务器端点地址</li>
</ul>
<p>客户端在调用<code>connect</code>之前不必非得调用<code>bind</code>方法，内核会确定源IP地址，并选择一个临时端口作为源端口。</p>
<h3>accept</h3>
<p>服务器端调用<code>accept</code>方法从处于监听状态的流套接字的客户连接请求队列中取出一个客户请求，并且创建一个新的套接字来与客户套接字创建连接通道。签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>该方法返回一个二元组<code>(new_sock, addr)</code>，<code>new_sock</code>表示连接套接字，<code>addr</code>表示客户端端点，也是一个二元组。</p>
<h3>send</h3>
<p><code>send</code>方法用于<code>TCP</code>套接字或调用了<code>connete</code>方法的<code>UDP</code>客户端套接字发送数据。签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>该方法返回已成功发送的比特数。</p>
<h3>sendto</h3>
<p>用于<code>UDP</code>服务器套接字，和未调用<code>connect</code>方法的<code>UDP</code>客户端套接字。签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sendto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">pass</span>
</pre></div>


<p>该方法返回已成功发送的比特数。</p>
<h3>recv</h3>
<p>用于从<code>TCP</code>连接连接的另一端接受数据，或者从调用了<code>connec</code>t方法的<code>UDP</code>客户端套接字接受服务器发来的的数据。签名：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffersize</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  recv(buffersize[, flags]) -&gt; data</span>
<span class="sd">  Receive up to buffersize bytes from the socket.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">pass</span>
</pre></div>


<h3>recvfrom</h3>
<p>用于从<code>UDP</code>服务器套接字与未调用<code>connect</code>方法的<code>UDP</code>客户端套接字接受数据。签名：</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">recvfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffersize</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  recvfrom(buffersize[, flags]) -&gt; (data, address info)</span>
<span class="sd">  Like recv(buffersize, flags) but also return the sender&#39;s address info.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">pass</span>
</pre></div>


<h3>小结</h3>
<p>上面介绍了Python Socket类的常见接口，这里来作一小结：</p>
<ul>
<li><strong>socket/__init__</strong>：创建套接字</li>
<li><strong>bind</strong>：绑定套接字的本地IP地址和端口号。<em>客户端通常不需要</em></li>
<li><strong>listen</strong>：置服务器端TCP套接字为监听状态，并设置队列大小。<em>仅用于服务端TCP套接字</em></li>
<li><strong>accept</strong>：提取一个连接请求，并创建新的连接套接字。<em>仅用于服务端TCP套接字</em></li>
<li><strong>recv</strong>：接受数据。仅用于TCP套接字或连接模式的客户端UDP套接字</li>
<li><strong>send</strong>：发送数据。仅用于TCP套接字或连接模式的客户端UDP套接字</li>
<li><strong>connect</strong>：“连接”服务器。仅用于客户端</li>
<li><strong>sendto</strong>：发送数据包。用于非连接模式的UDP套接字</li>
<li><strong>recvfrom</strong>：接受数据包。用于非连接模式的UDP套接字</li>
<li><strong>close</strong>：释放套接字。</li>
</ul>
<h2>实战</h2>
<p>现在，我们就这些 API 构建一个简单的 TCP 服务器，对于客户端发送的任何请求，我们均返回<code>Hello TCP</code>；也用Python实现了一个简单的客户端。</p>
<h3>TCP应用的 Socket API 调用流程</h3>
<p>TCP应用的 Socket API 调用的基本流程如下图所示：</p>
<p><img alt="Socket API调用基本流程" src="/../img/Socket API调用基本流程.png"></p>
<p>TCP客户端流程：</p>
<ol>
<li>确定服务器IP地址与端口号</li>
<li>创建套接字</li>
<li>分配本地端点地址(不需要显性完成)</li>
<li>连接服务器</li>
<li>遵循应用层协议进行通信</li>
<li>关闭套接字</li>
</ol>
<p>TCP服务端流程：</p>
<ol>
<li>创建主套接字，并绑定熟知端口号</li>
<li>设置主套接字为被动监听模式</li>
<li>主套接字接受下一个连接请求，创建新套接字用于与该客户建立连接</li>
<li>遵循应用层协议，通过新套接字反复接收客户请求，构造并发送响应</li>
<li>关闭与该客户之间的连接，并返回步骤3</li>
</ol>
<h3>服务端</h3>
<p>这里的服务端实现和流程图不一样的地方是使用了多线程，这样就能并发处理连接请求。</p>
<div class="codehilite"><pre><span></span><span class="c1"># coding=utf-8</span>

<span class="c1"># 导入socket库</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="c1"># 创建socket对象</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># 绑定端点</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="c1"># 监听</span>
<span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="c1"># 接受连接请求</span>
  <span class="n">ns</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
  <span class="c1"># 并发处理请求</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tcp_link</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
  <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

 <span class="c1"># 处理请求</span>
<span class="k">def</span> <span class="nf">tcp_link</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
  <span class="c1"># 接受数据</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
  <span class="c1"># 发送数据</span>
  <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;Hello TCP&#39;</span><span class="p">)</span>
  <span class="c1"># 关闭连接套接字</span>
  <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<h3>客户端</h3>
<p>客户端实现相对简单点。</p>
<div class="codehilite"><pre><span></span><span class="c1"># coding=utf-8</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="c1"># 创建套接字</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># 建立连接:</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="c1"># 发送数据:</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="c1">#  关闭套接字</span>
<span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>至此，我们根据 <code>Socket API</code> 实现了一个简单的<code>TCP</code>服务器和客户端。</p>

    
        <p class=tags>This entry was tagged
        
            <a href="/tags/socket/">socket</a>
    

    
</div>




<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</div>
</body>
</html>
