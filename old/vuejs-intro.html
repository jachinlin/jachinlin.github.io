<!doctype html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Vue 入门 | Vue 入门</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" media="screen">
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link href="/feed.atom" rel="alternate" title=" Vue 入门" type="application/atom+xml">
    
    <link rel="stylesheet" href="/static/pygments.css"  type="text/css">
    
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?7972bc564f84e320d4f261fe1ada61da";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

</head>

<body>
<div class="container box">



<div>
        <h1>Vue 入门</h1>

    <h1>组件</h1>
<p>简言之，现代前端开发就是<strong>组件</strong>开发，一个组件一般包含state、view、actions三个部分</p>
<ul>
<li>状态state：驱动应用的数据源</li>
<li>视图view：将state映射到视图，视图是状态的纯函数，view=f(state)</li>
<li>行为actions：响应在view上的用户输入导致的state变化</li>
</ul>
<p>组件之间可以嵌套，最后组成一棵组件树
<img alt="" src="https://cn.vuejs.org/images/components.png">
例如，一个网页应用可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>最后，我们将根组件挂载到index.html某个dom节点上就行了。</p>
<p>vue.js就是这样一个支持组件开发的javascript框架。现在，来学学vue.js吧。</p>
<h3>Vue 入门</h3>
<h5>如何定义组件，根组件和其他组件有什么异同?</h5>
<h5>如何将Vue实例(根组件)挂载到index.html上?</h5>
<h5>Vue生命周期都提供了哪些勾子？</h5>
<h5>如何定义视图？</h5>
<h5>如何定义状态？</h5>
<h5>如何定义行为和响应行为？</h5>
<h5>组件如何嵌套？</h5>
<h5>组件之间如何通信？</h5>
<p>带着这些问题，阅读下官网文档，应该没多大难度。</p>
<h1>Vuex是什么？</h1>
<p><a href="https://vuex.vuejs.org/zh/">vuex官方文档</a>笔记摘要</p>
<p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态。</p>
<h3>为什么需要Vuex?</h3>
<p>一个vue组件一般包含state、view、actions三个部分</p>
<ul>
<li>状态state：驱动应用的数据源</li>
<li>视图view：将state映射到视图，view=f(state)</li>
<li>行为actions：响应在view上的用户输入导致的state变化</li>
</ul>
<p>当多个组件需要共享状态时，代码的可维护性就会变得异常差。</p>
<p>因此，我们把组件的共享状态抽取出来（称为应用层级状态），以一个全局的单例模式进行管理，这就是<strong>状态管理</strong>。</p>
<p>通过定义和隔离状态管理中的各种概念，并强制遵守一定的规则，我们的代码就会变的更加结构化且易维护。所以，我们需要学习vuex中的<strong>核心概念</strong>，和需要遵守的<strong>编码规则</strong>。</p>
<h3>核心概念</h3>
<ul>
<li><strong>Store</strong>：一个状态管理实例就称为一个store。</li>
<li><strong>State</strong>：store中包含全部的应用层级状态的对象称为state</li>
<li><strong>Getter</strong>：由state派生出来的状态，可认为是store计算状态。getter是一个函数，它接受state作为第一个参数</li>
<li><strong>Mutation</strong>：我们不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化。mutation也是一个函数，它接受state作为第一个参数。</li>
<li><strong>Action</strong>：为了追踪状态的变化，规定mutation必须是同步函数。为了异步操作，于是引入了action。<strong>action</strong>提交的是mutation，而不是直接变更状态。action是一个函数，参数是一个context对象，在不考虑module的情况下，context对象可认为是一个store对象。</li>
<li><strong>Module</strong>：应用的所有状态都集中到一个对象，当应用变得非常复杂时，store对象就有可能变得相当臃肿。于是有了module。vuex允许我们将store分割成多个模块，每个字模块拥有自己的state、mutation、getter、action。</li>
</ul>
<h3>规则</h3>
<ol>
<li>应用层级的状态应该集中到单个 store 对象中</li>
<li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的</li>
<li>异步逻辑都应该封装到 <strong>action</strong> 里面</li>
</ol>
<h3>回顾</h3>
<ol>
<li>vuex是什么</li>
<li>为什要引入vuex</li>
<li>vuex都包含哪些部分，每个部分都是做什么的</li>
<li>使用vuex需要遵循哪些规则</li>
</ol>
<h1>webpack是什么</h1>
<p><a href="https://webpack.js.org/concepts/">webpack官方文档</a>概念摘要</p>
<p>WebPack是一个模块打包工具。</p>
<p><img alt="" src="http://webpack.github.io/assets/what-is-webpack.png"></p>
<h3>为什么需要webpack</h3>
<p>现今的很多网页都是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>
<ul>
<li><strong>模块化</strong>，让我们可以把复杂的程序细化为小的模块;</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器</li>
<li>...</li>
</ul>
<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>
<h3>webpack 核心概念</h3>
<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>
<h5>entry</h5>
<p><strong>入口起点(entry point)</strong>指示 webpack 应该使用哪个模块，来作为构建其内部<em>依赖图</em>的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的</p>
<h5>output</h5>
<p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundles</em>，以及如何命名这些文件</p>
<h5>loader</h5>
<p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://webpack.docschina.org/concepts/modules">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<h5>plugins</h5>
<p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<a href="https://webpack.docschina.org/api/plugins">插件接口</a>功能极其强大，可以用来处理各种各样的任务。</p>
<h1>什么是路由router？</h1>
<p>在网站开发中，路由通常是指随着浏览器URL的变化，网页UI也跟着变化这个过程。想象一下，当我们点击一个链接，浏览器URL从 <code>https://website.com</code>变成<code>https://website.com/articles</code>，网页刷新呈现出新的内容，这个过程就是路由。可以用这个<code>view = route(url)</code>函数表示路由。</p>
<p>在之前的网站开发中，每次URL变化时，客户端（例如浏览器）都会向服务器发起一次请求，然后渲染成页面，我们把这种路由方式称作服务端路由。</p>
<p>现在，我们更多的是采用<code>客户端路由</code>方式（见<a href="https://medium.freecodecamp.org/heres-why-client-side-rendering-won-46a349fadb52">Here’s Why Client-side Rendering Won</a>）——客户端只有在初始化过程向服务端发起一次请求，之后，应用URL的任何变化都是由客户端自己响应处理。</p>
<h3>vue-router 核心概念</h3>
<p>Vue-router就是vuejs的客户端路由插件，在vue router中，路由是指url到component的映射。</p>
<p><strong>routes</strong>：路由映射集，每个路由映射一个组件</p>
<p><strong>router-link</strong>：使用 router-link 组件来导航，<code>&lt;router-link&gt;</code> 默认会被渲染成一个 <code>&lt;a&gt;</code> 标签 （动态路由、嵌套路由等高级玩法见官网文档）</p>
<p><strong>router-view</strong>：路由出口，路由匹配到的组件将通过router-view组件渲染</p>
<p><strong>编程式导航</strong>：除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法<code>router.push</code> ，通过编写代码来实现</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;router-link :to="..."&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody>
</table>
<h3>回顾</h3>
<ul>
<li>什么是路由</li>
<li>vue-router如何使用</li>
</ul>

    
        <p class=tags>标签：
        <a href="/tags/VueJS/">VueJS</a>
    

    
</div>



</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
