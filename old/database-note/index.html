<!doctype html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>数据库并发控制笔记 | 数据库并发控制笔记</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" media="screen">
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link href="/feed.atom" rel="alternate" title=" 数据库并发控制笔记" type="application/atom+xml">
    
    <link rel="stylesheet" href="/static/_pygments.css"  type="text/css">
    
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?7972bc564f84e320d4f261fe1ada61da";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

</head>

<body>
<div class="box">



<div class="container">
        <h1 class="title">数据库并发控制笔记</h1>

    <h2>并发现象</h2>
<p>数据库里面对数据进行并发处理的时候，如果不进行控制可能出现的三个现象：</p>
<p>脏读、不可重复读、幻读</p>
<h3>脏读 Dirty Read</h3>
<p>脏读，是指一个事务读取另外一个事务还没有提交的数据叫脏读。</p>
<p>具体来说就是在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p>
<h3>不可重复读 Nonrepeatable Read</h3>
<p>不可重复读是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。</p>
<p>这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p>
<h3>幻读 Phantom Read</h3>
<p>所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行<code>Phanto row</code>。</p>
<p>例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p>
<h3>小结</h3>
<p>三种现象其实就是同一回事，事务T1读写数据时，事务T2在这期间对同样的数据集做了其他操作，导致事务T1出现各种问题。</p>
<h2>事务隔离</h2>
<p>当多个事务同时进行时，通过设置隔离级别来处理脏读、不可重复读、幻读现象。</p>
<p>事务指定一个隔离级别，该隔离级别定义一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。</p>
<p>在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<h3>未提交读（Read uncommitted）</h3>
<p>在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。这个级别会导致很多问题，从性能上来说，未提交读不会比其他的级别好太多，但是缺乏其他级别的很多好处，在实际应用中一般很少使用。</p>
<p>这个级别相当于没有隔离。</p>
<h3>提交读（Read committed）</h3>
<p>提交读满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</p>
<p>大多数数据库系统的默认隔离级别都是提交读。</p>
<h3>可重复读（Repeatable read）</h3>
<p>当使用可重复读隔离级别时，在事务执行期间会锁定该事务以任何方式引用的所有行。因此，如果在同一个事务中发出同一个SELECT语句两次或更多次，那么产生的结果数据集总是相同的。可重复读解决了脏读的问题，也保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读问题。</p>
<p>可重复读是MySQL的默认事务隔离级别。</p>
<h3>可串行化（Serializable）</h3>
<p>可串行化通过强制事务串行执行，避免了前面所说的幻读问题。简单来说，可串行化会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。</p>
<p>可串行化是最高的隔离级别，实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。</p>
<h2>PostgreSQL 最近遇到的问题</h2>
<p>PostgreSQL 实现了一下几种事务隔离级别：</p>
<p><img alt="pg-transaction-iso" src="/../img/pg-transaction-iso.png"></p>
<p>PG除了考虑到脏读、不可重复读、幻读，还考虑到了<code>serialization anomaly</code>：</p>
<blockquote>
<p>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</p>
</blockquote>
<p>不过这里有两点需要注意：</p>
<blockquote>
<p>In PostgreSQL, you can  request any of the four standard transaction isolation levels,  but internally only three distinct isolation levels are  implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like  Read Committed. This is because it is the only sensible way to  map the standard isolation levels to PostgreSQL's multiversion  concurrency control architecture.</p>
</blockquote>
<p>隔离级别<code>Read Uncommitted</code>和 <code>Read Committed</code>的效果一样。</p>
<blockquote>
<p>The table also shows that PostgreSQL's Repeatable Read  implementation does not allow phantom reads. Stricter behavior is  permitted by the SQL standard: the four isolation levels only  define which phenomena must not happen, not which phenomena  <em>must</em> happen. The behavior  of the available isolation levels is detailed in the following  subsections.</p>
</blockquote>
<p>除了会引起<code>serialization anomaly</code>，<code>Repeatable Read</code>和<code>Serializable</code>的效果一样。</p>
<p>暂时不关心<code>serialization anomaly</code>，所以先来看一下<code>读已提交隔离级别</code>和 <code>可重复读隔离级别</code>两者的定义吧。</p>
<h3>读已提交隔离级别</h3>
<p>读已提交是PostgreSQL里的缺省隔离级别。当一个事务运行在这个隔离级别时， SELECT查询(没有FOR UPDATE/SHARE子句)只能看到查询开始之前已提交的数据而无法看到未提交的数据或者在查询执行期间其它事务已提交的数据 。实际上，SELECT 查询看到一个在查询开始运行的瞬间该数据库的一个快照。 不过，SELECT看得见其自身所在事务中前面更新执行结果。即使它们尚未提交。请注意，在同一个事务里两个相邻的SELECT命令可能看到不同的快照，因为其它事务会在第一个SELECT执行期间提交。</p>
<p>UPDATE, DELETE, SELECT FOR UPDATE和SELECT FOR SHARE命令在搜索目标行时的行为和SELECT一样： 它们只能找到在命令开始的时候已经提交的行。不过， 这样的目标行在被找到的时候可能已经被其它并发事务更新、删除、锁住。在这种情况下， 即将进行的更新将等待第一个事务提交或者回滚(如果它还在处理)。如果第一个事务回滚， 那么它的作用将被忽略，而第二个事务将继续更新最初发现的行。如果第一个事务提交， 那么如果第一个事务删除了该行，则第二个事务将忽略该行， 否则它将试图在该行的已更新的版本上施加它的操作。系统将重新计算命令搜索条件(WHERE子句)， 看看该行已更新的版本是否仍然符合搜索条件。如果符合，则第二个事务从该行的已更新版本开始继续其操作。 如果是SELECT FOR UPDATE和SELECT FOR SHARE则意味着把已更新的行版本锁住并返回给客户端。</p>
<h3>可重复读隔离级别</h3>
<p>这个级别和读已提交级别是不一样的。重复读事务中的查询看到的是事务开始时的快照， 而不是该事务内部当前查询开始时的快照，这样，同一个事务内部后面的SELECT命令总是看到同样的数据等，它们没有看到通过自身事务开始之后提及的其他事务做出的改变。</p>
<p>使用这个级别的应用必须准备好重试事务，因为串行化失败。</p>
<p>UPDATE, DELETE, SELECT FOR UPDATE和SELECT FOR SHARE在搜索目标行时的行为和SELECT一样： 它们将只寻找在事务开始的时候已经提交的目标行。但是， 这样的目标行在被发现的时候可能已经被另外一个并发的事务更新、删除、锁住。在这种情况下， 可串行化的事务将等待第一个正在更新的事务提交或者回滚(如果它仍然在处理中)。如果第一个事务回滚， 那么它的影响将被忽略，而这个可串行化的就可以继续更新它最初发现的行。 但是如果第一个事务被提交了(并且实际上更新或者删除了该行，而不只是锁住它)那么可串行化事务将回滚， 并返回下面信息：</p>
<div class="codehilite"><pre><span></span><span class="n">ERROR</span><span class="o">:</span>  <span class="n">could</span> <span class="n">not</span> <span class="n">serialize</span> <span class="n">access</span> <span class="n">due</span> <span class="n">to</span> <span class="n">concurrent</span> <span class="n">update</span>
</pre></div>


<p>因为一个可串行化的事务在开始之后不能更改或者锁住被其它事务更改过的行。</p>
<h3>最近遇到的问题</h3>
<p>至此，最近遇到的问题总算解决了。</p>
<p><img alt="pg-error" src="/../img/pg-error.jpeg"></p>
<p>参考：</p>
<ul>
<li>官方文档：<a href="https://www.postgresql.org/docs/current/static/transaction-iso.html">https://www.postgresql.org/docs/current/static/transaction-iso.html</a></li>
<li>译文参考：<a href="http://blog.163.com/xh_ding/blog/static/19390328920154774016755/">http://blog.163.com/xh_ding/blog/static/19390328920154774016755/</a></li>
</ul>

    
        <p class=tags>This entry was tagged
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    

    
</div>




<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</div>
</body>
</html>
