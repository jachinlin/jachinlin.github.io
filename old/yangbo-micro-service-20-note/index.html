<!doctype html>
<html>
<head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>《微服务架构核心20讲》笔记 | 《微服务架构核心20讲》笔记</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" media="screen">
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link href="/feed.atom" rel="alternate" title=" 《微服务架构核心20讲》笔记" type="application/atom+xml">
    
    <link rel="stylesheet" href="/static/pygments.css"  type="text/css">
    
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?7972bc564f84e320d4f261fe1ada61da";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

</head>

<body>
<div class="box">



<div class="container">
        <h1 class="title">《微服务架构核心20讲》笔记</h1>

    <h3>什么是微服务架构</h3>
<p>Martin Fowler认为微服务是一种架构风格：</p>
<ul>
<li>将单体应⽤用划分成一组小的服务，服务之间相互协作，实现业务功能</li>
<li>每个服务运行在独⽴立的进程中</li>
<li>服务间采用轻量量级的通信机制协作（通常是HTTP/JSON）</li>
<li>每个服务围绕业务能力进行构建（比如用户服务、登录服务、商品服务等等）</li>
<li>每个服务能够通过自动化机制独立地部署</li>
<li>很少有集中式的服务管理理，每个服务可以使⽤不同的语言开发，使用不同的存储技术</li>
</ul>
<p>Netflix前架构总监Adrian Cockcroft认为微服务是</p>
<blockquote>
<p>Loosely coupled service oriented architecture with bounded context。基于</p>
<p>有界上下文的、松散耦合的面向服务的架构</p>
</blockquote>
<p>这个定义比较抽象，大致是说微服务有以下三个特性：</p>
<ul>
<li>loosely coupled：服务之间松散耦合</li>
<li>service oriented architecture：面向服务架构</li>
<li>bounded context：有界上下文，或者说局部状态，是指每个团队维护自己的数据源</li>
</ul>
<h3>架构师如何权衡微服务的利弊</h3>
<table>
<thead>
<tr>
<th>利</th>
<th>弊</th>
</tr>
</thead>
<tbody>
<tr>
<td>强模块化辩解</td>
<td>分布式系统复杂性</td>
</tr>
<tr>
<td>可独立部署</td>
<td>最终一致性</td>
</tr>
<tr>
<td>技术多样性</td>
<td>运维复杂性、测试复杂性</td>
</tr>
</tbody>
</table>
<h3>康威法则和微服务给架构师怎样的启示</h3>
<blockquote>
<p>Conway’s law: Organizations which design systems[...] are constrained to produce designs which are copies of the communication structures of these organizations.</p>
</blockquote>
<p>简单说就是，组织架构和系统架构之间有一个映射关系。从单块架构到微服务架构是这个定律的很到体现：团队是分布式的（多个团队），系统架构是单块的，开发、测试、部署协调沟通成本大，严重影响效率，严重时团队之间还容易起冲突；将单块架构解耦成微服务，每个团队开发、测试和发布自己负责的微服务，互不干扰，系统效率得到提升。</p>
<p>系统架构要与组织架构相匹配。</p>
<h3>企业因该在什么时候开始考虑引入微服务</h3>
<p><img alt="" src="/img/micro-service-when.png"></p>
<p>单块应用优先，随着业务复杂性变高，系统复杂性变高，再向微服务演化。（团队超100人，就需要考虑微服务了）</p>
<p>微服务是演化式架构。</p>
<h3>如何给出一个清晰简洁的服务分层方式</h3>
<p><img alt="" src="/img/micro-service-level.png"></p>
<p>基础服务：例如用户服务、购物车服务等</p>
<p>聚合服务：针对不同端聚合或者裁剪</p>
<h3>微服务总体技术架构体系是怎样设计的</h3>
<p><img alt="" src="/img/micor-service-archetecture.png"></p>
<p>​</p>
<h3>微服务最经典的三种服务发现机制</h3>
<h5>1、什么是服务发现</h5>
<p>想象一下编写代码调用REST或者Thrift API的服务，为了实现这个调用，你的代码需要知道服务实例的网络位置（IP 地址和端口）。在运行在物理硬件的传统应用中，服务实例的网络位置是相对静止的。例如，代码可以从配置文件中读取网络位置，这个配置文件偶尔会更新。
但是，在现代基于云的微服务应用中，这是非常难以解决的问题。<strong>服务实例被动态地赋予网路位置</strong>。另外，由于自动伸缩、故障和升级，<strong>服务实例集合经常会动态改变</strong>。所以客户端代码需要使用详细设计的服务发现机制。
对于客户端来说就是服务发现，对于服务端来说就是服务注册。</p>
<p>参考 <a href="https://www.nginx.com/blog/introduction-to-microservices/">Introduction to Microservices</a></p>
<h5>2、服务发现机制</h5>
<p>服务端发现模式</p>
<p><img alt="" src="/img/micro-service-server-side-pattern.png"></p>
<p>客户端发现模式——独立进程LB</p>
<p><img alt="" src="/img/micro-service-discovery1.png"></p>
<p>客户端发现模式——进程内LB</p>
<p><img alt="" src="/img/micro-service-discovery2.png"></p>
<p>开源实现:</p>
<ul>
<li><a href="https://github.com/Netflix/eureka">eureka</a></li>
<li><a href="https://github.com/hashicorp/consul">consul</a></li>
</ul>
<h3>微服务API服务网关原理</h3>
<h5>1、为什么需要网关</h5>
<p>一个公司内部一般有很多微服务，比方说有购物车服务、库存服务、推荐服务、订单服务等等，这些微服务是每个团队各自去对立维护的。但是我们不希望外部的客户访问的时候知道这些细节，这时候就可以让网关来屏蔽这些内部细节，让这些服务看上去是一个服务。简言之，</p>
<p><strong>网关能够屏蔽内部的服务细节，对外提供统一的接口</strong></p>
<h5>2、网关功能</h5>
<ul>
<li>反向路由：将外部的请求转化为内部的服务调用</li>
<li>认证安全：预防爬虫行为或者攻击行为</li>
<li>限流熔断：防止突发流量击垮内部服务</li>
<li>监控日志：访问审计</li>
</ul>
<h5>3、开源实现</h5>
<ul>
<li><a href="https://github.com/Netflix/zuul">Zuul</a></li>
<li><a href="https://github.com/kong/kong">Kong</a></li>
</ul>
<h3>根Netflix学习微服务路由发现体系</h3>
<p>服务分层 + 服务注册／发现 + API网关 体系</p>
<p><img alt="" src="/img/micro-service-discovery2.png"></p>
<h3>集中式配置中心的作用和原理是什么</h3>
<h5>1、什么需要配置中心</h5>
<p>没有配置中心的话，开发人员一般把配置放在配置文件里，而且各自有各自的做法，这样做有蛮多的隐患，一个是配置不标准、格式不统一；另外一个是这些配置上线以后如果你要去修改它，可能需要重新发布，这个周期会比较长，这对业务的影响有时候是非常大的。此外，如果没有一个完整的配置系统，那么谁设置了这个配置，谁对配置进行修改，我们是不知道的，没有审计功能，事后我们很难去追溯，这就是集中式配置中心所要解决的问题。</p>
<h5>2、原理</h5>
<p><img alt="" src="/img/config-center.png"></p>
<h5>3、开源实现</h5>
<ul>
<li><a href="https://github.com/ctripcorp/apollo">apollo</a></li>
<li><a href="https://github.com/spring-cloud/spring-cloud-config">spring cloud config</a></li>
<li><a href="https://github.com/knightliao/disconf">disconf</a></li>
</ul>
<h3>微服务通信方式</h3>
<p>服务之间服务通信方法有 RPC 和 restful</p>
<table>
<thead>
<tr>
<th></th>
<th>RPC</th>
<th>RESTFUL</th>
</tr>
</thead>
<tbody>
<tr>
<td>耦合性</td>
<td>强耦合</td>
<td>松散耦合</td>
</tr>
<tr>
<td>消息协议</td>
<td>二进制thrift、protobuf、avro</td>
<td>文本XML，Json</td>
</tr>
<tr>
<td>通信协议</td>
<td>TCP</td>
<td>HTTP／HTTP2</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>一般低于RPC</td>
</tr>
<tr>
<td>接口契约IDL</td>
<td>Thrift、protobuf idl</td>
<td>swagger</td>
</tr>
<tr>
<td>客户端</td>
<td>强类型客户端，一般自动生成</td>
<td>一般HTTP client可访问</td>
</tr>
<tr>
<td>案例</td>
<td>dubbo、grpc、thrift</td>
<td></td>
</tr>
<tr>
<td>开发者友好</td>
<td>客户端比较方便、二进制消息不可读</td>
<td>文本消息可读</td>
</tr>
<tr>
<td>对外开放</td>
<td>对外一般需要转换成REST/文本协议</td>
<td>直接对外开放</td>
</tr>
</tbody>
</table>
<h3>微服务框架需要考虑哪些治理环节</h3>
<h3>微服务监控系统分层和监控架构</h3>
<h3>微服务的调用链监控如何选型</h3>
<h3>微服务的容错限流是如何工作的</h3>
<h3>Docker容器部署技术&amp;持续交付流水线</h3>
<h3>容器集群调度和基于容器的发布体系</h3>

    
        <p class=tags>This entry was tagged
        
            <a href="/tags/micro%20service/">micro service</a>
    

    
</div>




<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</div>
</body>
</html>
